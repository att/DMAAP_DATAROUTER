/*
 *                        AT&T - PROPRIETARY
 *          THIS FILE CONTAINS PROPRIETARY INFORMATION OF
 *        AT&T AND IS NOT TO BE DISCLOSED OR USED EXCEPT IN
 *             ACCORDANCE WITH APPLICABLE AGREEMENTS.
 *
 *          Copyright (c) 2013 AT&T Knowledge Ventures
 *              Unpublished and Not for Publication
 *                     All Rights Reserved
 */

package com.att.research.datarouter.provisioning;

import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Properties;

import javax.servlet.ServletConfig;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONTokener;

import com.att.eelf.configuration.EELFLogger;
import com.att.eelf.configuration.EELFManager;
import com.att.research.datarouter.provisioning.beans.EventLogRecord;
import com.att.research.datarouter.provisioning.beans.Feed;
import com.att.research.datarouter.provisioning.beans.IngressRoute;
import com.att.research.datarouter.provisioning.eelf.EelfMsgs;
import com.att.research.datarouter.provisioning.utils.*;

/**
 * This servlet handles redirects for the &lt;publishURL&gt; on the provisioning server,
 * which is generated by the provisioning server to handle a particular subscriptions to a feed.
 * See the <b>File Publishing and Delivery API</b> document for details on how these methods
 * should be invoked.
 *
 * @author Robert Eby
 * @version $Id: PublishServlet.java,v 1.8 2014/03/12 19:45:41 eby Exp $
 */
@SuppressWarnings("serial")
public class PublishServlet extends BaseServlet {
	private int next_node;
	private String provstring;
	private List<IngressRoute> irt;
	//Adding EELF Logger Rally:US664892  
    private static EELFLogger eelflogger = EELFManager.getInstance().getLogger("com.att.research.datarouter.provisioning.PublishServlet");
    

	@Override
	public void init(ServletConfig config) throws ServletException {
		super.init(config);
		next_node = 0;
		provstring = "";
		irt = new ArrayList<IngressRoute>();
	
	}
	@Override
	public void doDelete(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		setIpAndFqdnForEelf("doDelete");
		eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF_AND_FEEDID, req.getHeader(BEHALF_HEADER),getIdFromPath(req)+"");
		redirect(req, resp);
	}
	@Override
	public void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		setIpAndFqdnForEelf("doGet");
		eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF_AND_FEEDID, req.getHeader(BEHALF_HEADER),getIdFromPath(req)+"");
		redirect(req, resp);
	}
	@Override
	public void doPut(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		setIpAndFqdnForEelf("doPut");
		eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF_AND_FEEDID, req.getHeader(BEHALF_HEADER),getIdFromPath(req)+"");
		redirect(req, resp);
	}
	@Override
	public void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		setIpAndFqdnForEelf("doPost");
		eelflogger.info(EelfMsgs.MESSAGE_WITH_BEHALF, req.getHeader(BEHALF_HEADER));
		redirect(req, resp);
	}
	private void redirect(HttpServletRequest req, HttpServletResponse resp) throws IOException {
		String[] nodes = getNodes();
		if (nodes == null || nodes.length == 0) {
			resp.sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE, "There are no nodes defined in the DR network.");
		} else {
			EventLogRecord elr = new EventLogRecord(req);
			int feedid = checkPath(req);
			if (feedid < 0) {
				String message = (feedid == -1)
					? "Invalid request - Missing or bad feed number."
					: "Invalid request - Missing file ID.";
				elr.setMessage(message);
				elr.setResult(HttpServletResponse.SC_NOT_FOUND);
				eventlogger.info(elr);

				resp.sendError(HttpServletResponse.SC_NOT_FOUND, message);
			} else {
				// Generate new URL
				String nextnode = getRedirectNode(feedid, req);
				nextnode = nextnode+":"+DB.HTTPS_PORT;
				String newurl = "https://" + nextnode + "/publish" + req.getPathInfo();
				String qs = req.getQueryString();
				if (qs != null)
					newurl += "?" + qs;

				// Log redirect in event log
				String message = "Redirected to: "+newurl;
				elr.setMessage(message);
				elr.setResult(HttpServletResponse.SC_MOVED_PERMANENTLY);
				eventlogger.info(elr);

				resp.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
				resp.setHeader("Location", newurl);
			}
		}
	}
	private String getRedirectNode(int feedid, HttpServletRequest req) {
		// Check to see if the IRT needs to be updated
		Poker p = Poker.getPoker();
		String s = p.getProvisioningString();
		synchronized (provstring) {
			if (irt == null || (s.length() != provstring.length()) || !s.equals(provstring)) {
				// Provisioning string has changed -- update the IRT
				provstring = s;
				JSONObject jo = new JSONObject(new JSONTokener(provstring));
				JSONArray ja = jo.getJSONArray("ingress");
				List<IngressRoute> newlist = new ArrayList<IngressRoute>();
				for (int i = 0; i < ja.length(); i++) {
					IngressRoute iroute = new IngressRoute(ja.getJSONObject(i));
					newlist.add(iroute);
				}
				irt = newlist;
			}
		}

		// Look in IRT for next node
		for (IngressRoute route : irt) {
			if (route.matches(feedid, req)) {
				// pick a node at random from the list
				Collection<String> nodes = route.getNodes();
				String[] arr = nodes.toArray(new String[0]);
				long id = System.currentTimeMillis() % arr.length;
				String node = arr[(int) id];
				intlogger.info("Redirecting to "+node+" because of route "+route);
				return node;
			}
		}

		// No IRT rule matches, do round robin of all active nodes
		String[] nodes = getNodes();
		if (next_node >= nodes.length)	// The list of nodes may have grown/shrunk
			next_node = 0;
		return nodes[next_node++];
	}
	private int checkPath(HttpServletRequest req) {
		String path = req.getPathInfo();
		if (path == null || path.length() < 2)
			return -1;
		path = path.substring(1);
		int ix = path.indexOf('/');
		if (ix < 0 || ix == path.length()-1)
			return -2;
		try {
			int feedid = Integer.parseInt(path.substring(0, ix));
			if (!Feed.isFeedValid(feedid))
				return -1;
			return feedid;
		} catch (NumberFormatException e) {
			return -1;
		}
	}
}
